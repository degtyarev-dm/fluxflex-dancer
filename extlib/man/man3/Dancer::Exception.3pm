.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dancer::Exception 3"
.TH Dancer::Exception 3 "2011-07-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Dancer::Exception qw(:all);
\&
\&  # raise an exception
\&  raise E_HALTED;
\&
\&  # get a list of possible exceptions
\&  my @exception_names = list_exceptions;
\&
\&  # catch an exception
\&  eval { ... };
\&  if ( my $value = is_dancer_exception(my $exception = $@) ) {
\&    if ($value == ( E_HALTED | E_FOO ) ) {
\&        # it\*(Aqs a halt or foo exception...
\&    }
\&  } elsif ($exception) {
\&    # do something with $exception (don\*(Aqt use $@ as it may have been reset)
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a lighweight exceptions module. Yes, it's not Object Oriented, that's
on purpose, to keep it light and fast. Thus, you can use \fIref()\fR instead of
\&\->\fIisa()\fR, and exceptions have no method to call on. Simply dereference them to
get their value
.PP
An exception is a blessed reference on an integer. This integer is always a
power of two, so that you can test its value using the \f(CW\*(C`|\*(C'\fR operator. A Dancer
exception is always blessed as \f(CW\*(AqDancer::Exception\*(Aq\fR.
.SH "EXPORTS"
.IX Header "EXPORTS"
to be able to use this module, you should use it with these options :
.PP
.Vb 2
\&  # loads specific exceptions only. See list_exceptions for a list
\&  use Dancer::Exception qw(E_HALTED E_PLOP);
\&
\&  # loads the utility functions
\&  use Dancer::Exception qw(raise list_exceptions is_dancer_exception register_custom_exception);
\&
\&  # this does the same thing as above
\&  use Dancer::Exception qw(:utils);
\&
\&  # loads all exception names, but not the utils
\&  use Dancer::Exception qw(:exceptions);
\&
\&  # loads only the internal exception names
\&  use Dancer::Exception qw(:internal_exceptions);
\&
\&  # loads only the custom exception names
\&  use Dancer::Exception qw(:custom_exceptions);
\&
\&  # loads everything
\&  use Dancer::Exception qw(:all);
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "raise"
.IX Subsection "raise"
.Vb 1
\&  raise E_HALTED;
.Ve
.PP
Used to raise an exception. Takes in argument an integer (must be a power of
2). You should give it an existing Dancer exception.
.SS "list_exceptions"
.IX Subsection "list_exceptions"
.Vb 3
\&  my @exception_names = list_exceptions;
\&  my @exception_names = list_exceptions(type => \*(Aqinternal\*(Aq);
\&  my @exception_names = list_exceptions(type => \*(Aqcustom\*(Aq);
.Ve
.PP
Returns a list of strings, the names of available exceptions.
.PP
Parameters are an optional list of key values. Accepted keys are for now only
\&\f(CW\*(C`type\*(C'\fR, to restrict the list of exceptions on the type of the Dancer
exception. \f(CW\*(C`type\*(C'\fR can be 'internal' or 'custom'.
.SS "is_dancer_internal_exception"
.IX Subsection "is_dancer_internal_exception"
.Vb 6
\&  # test if it\*(Aqs a Dancer exception
\&  my $value = is_dancer_exception($@);
\&  # test if it\*(Aqs a Dancer internal exception
\&  my $value = is_dancer_exception($@, type => \*(Aqinternal\*(Aq);
\&  # test if it\*(Aqs a Dancer custom exception
\&  my $value = is_dancer_exception($@, type => \*(Aqcustom\*(Aq);
.Ve
.PP
This function tests if an exception is a Dancer exception, and if yes get its
value. If not, it returns void
.PP
First parameter is the exception to test. Other parameters are an optional list
of key values. Accepted keys are for now only \f(CW\*(C`type\*(C'\fR, to restrict the test on
the type of the Dancer exception. \f(CW\*(C`type\*(C'\fR can be 'internal' or 'custom'.
.PP
Returns the exception value (which is always true), or void (empty list) if the
exception was not a dancer exception (of the right type if specified).
.SS "register_custom_exception"
.IX Subsection "register_custom_exception"
.Vb 3
\&  register_custom_exception(\*(AqE_FROBNICATOR\*(Aq);
\&  # now I can use this exception for raising
\&  raise E_FROBNICATOR;
.Ve
.SH "INTERNAL EXCEPTIONS"
.IX Header "INTERNAL EXCEPTIONS"
.SS "E_GENERIC"
.IX Subsection "E_GENERIC"
A generic purpose exception. Not used by internal code, so this exception can
be used by user code safely, without having to register a custom user exception.
.SS "E_HALTED"
.IX Subsection "E_HALTED"
Internal exception, generated when \f(CW\*(C`halt()\*(C'\fR is called (see in Dancer \s-1POD\s0).
.SH "CUSTOM EXCEPTIONS"
.IX Header "CUSTOM EXCEPTIONS"
In addition to internal (and the generic one) exception, users have the ability
to register more Dancer exceptions for their need. To do that, see
\&\f(CW\*(C`register_custom_exception\*(C'\fR.
