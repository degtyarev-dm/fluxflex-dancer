.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dancer::ModuleLoader 3"
.TH Dancer::ModuleLoader 3 "2011-07-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer::ModuleLoader \- dynamic module loading helpers for Dancer core components
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Taken directly from Dancer::Template::TemplateToolkit (which is core):
.PP
.Vb 2
\&    die "Template is needed by Dancer::Template::TemplateToolkit"
\&      unless Dancer::ModuleLoader\->load(\*(AqTemplate\*(Aq);
\&
\&    # we now have Template loaded
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes in Dancer core we need to use modules, but we don't want to declare
them all in advance in compile-time. These could be because the specific modules
provide extra features which depend on code that isn't (and shouldn't) be in
core, or perhaps because we only want these components loaded in lazy style,
saving loading time a bit. For example, why load Template (which isn't
required by Dancer) when you don't use Dancer::Template::TemplateToolkit?
.PP
To do such things takes a bit of code for localizing \f(CW$@\fR and \f(CW\*(C`eval\*(C'\fRing. That
code has been refactored into this module to help Dancer core developers.
.PP
\&\fBPlease only use this for Dancer core modules\fR. If you're writing an external
Dancer module (Dancer::Template::Tiny, Dancer::Session::Cookie, etc.),
please simply "\f(CW\*(C`use ModuleYouNeed\*(C'\fR" in your code and don't use this module.
.SH "METHODS/SUBROUTINES"
.IX Header "METHODS/SUBROUTINES"
.SS "load"
.IX Subsection "load"
Runs a "\f(CW\*(C`use ModuleYouNeed\*(C'\fR".
.PP
.Vb 4
\&    use Dancer::ModuleLoader;
\&    ...
\&    Dancer::ModuleLoader\->load(\*(AqSomething\*(Aq)
\&        or die "Couldn\*(Aqt load Something\en";
\&
\&    # load version 5.0 or more
\&    Dancer::ModuleLoader\->load(\*(AqSomething\*(Aq, \*(Aq5.0\*(Aq)
\&        or die "Couldn\*(Aqt load Something\en";
\&
\&    # load version 5.0 or more
\&    my ($res, $error) = Dancer::ModuleLoader\->load(\*(AqSomething\*(Aq, \*(Aq5.0\*(Aq);
\&    $res or die "Couldn\*(Aqt load Something : \*(Aq$error\*(Aq\en";
.Ve
.PP
Takes in arguments the module name, and optionally the minimum version number required.
.PP
In scalar context, returns 1 if successful, 0 if not.
In list context, returns 1 if successful, \f(CW\*(C`(0, "error message")\*(C'\fR if not.
.PP
If you need to give argumentto the loading module, please use the method \f(CW\*(C`load_with_params\*(C'\fR
.SS "require"
.IX Subsection "require"
Runs a "\f(CW\*(C`require ModuleYouNeed\*(C'\fR".
.PP
.Vb 6
\&    use Dancer::ModuleLoader;
\&    ...
\&    Dancer::ModuleLoader\->require(\*(AqSomething\*(Aq)
\&        or die "Couldn\*(Aqt require Something\en";
\&    my ($res, $error) = Dancer::ModuleLoader\->require(\*(AqSomething\*(Aq);
\&    $res or die "Couldn\*(Aqt require Something : \*(Aq$error\*(Aq\en";
.Ve
.PP
If you are unsure what you need (\f(CW\*(C`require\*(C'\fR or \f(CW\*(C`load\*(C'\fR), learn the differences
between \f(CW\*(C`require\*(C'\fR and \f(CW\*(C`use\*(C'\fR.
.PP
Takes in arguments the module name.
.PP
In scalar context, returns 1 if successful, 0 if not.
In list context, returns 1 if successful, \f(CW\*(C`(0, "error message")\*(C'\fR if not.
.SS "load_with_params"
.IX Subsection "load_with_params"
Runs a "\f(CW\*(C`use ModuleYouNeed qw(param1 param2 ...)\*(C'\fR".
.PP
.Vb 4
\&    use Dancer::ModuleLoader;
\&    ...
\&    Dancer::ModuleLoader\->load(\*(AqSomething\*(Aq, qw(param1 param2) )
\&        or die "Couldn\*(Aqt load Something\en";
\&
\&    my ($res, $error) = Dancer::ModuleLoader\->load(\*(AqSomething\*(Aq, @params);
\&    $res or die "Couldn\*(Aqt load Something : \*(Aq$error\*(Aq\en";
.Ve
.PP
Takes in arguments the module name, and optionally parameters to pass to the import internal method.
.PP
In scalar context, returns 1 if successful, 0 if not.
In list context, returns 1 if successful, \f(CW\*(C`(0, "error message")\*(C'\fR if not.
.SS "use_lib"
.IX Subsection "use_lib"
Runs a "\f(CW\*(C`use lib qw(path1 path2)\*(C'\fR" at run time instead of compile time.
.PP
.Vb 4
\&    use Dancer::ModuleLoader;
\&    ...
\&    Dancer::ModuleLoader\->use_lib(\*(Aqpath1\*(Aq, @other_paths)
\&        or die "Couldn\*(Aqt perform use lib\en";
\&
\&    my ($res, $error) = Dancer::ModuleLoader\->use_lib(\*(Aqpath1\*(Aq, @other_paths);
\&    $res or die "Couldn\*(Aqt perform use lib : \*(Aq$error\*(Aq\en";
.Ve
.PP
Takes in arguments a list of path to be prepended to \f(CW@INC\fR, in a similar way
than \f(CW\*(C`use lib\*(C'\fR. However, this is performed at run time, so the list of paths
can be generated and dynamic.
.PP
In scalar context, returns 1 if successful, 0 if not.
In list context, returns 1 if successful, \f(CW\*(C`(0, "error message")\*(C'\fR if not.
.SS "class_from_setting"
.IX Subsection "class_from_setting"
Given a setting in Dancer::Config, composes the class it should be.
.PP
This is the function that translates:
.PP
.Vb 2
\&    # in config.yaml
\&    template: "template_toolkit"
.Ve
.PP
To the class:
.PP
.Vb 1
\&    Dancer::Template::TemplateToolkit
.Ve
.PP
Example:
.PP
.Vb 4
\&    use Dancer::ModuleLoader;
\&    my $class = Dancer::ModuleLoader\->class_from_setting(
\&        \*(AqDancer::Template\*(Aq => \*(Aqtemplate_toolkit\*(Aq,
\&    );
\&
\&    # $class == \*(AqDancer::Template::TemplateToolkit
\&
\&    $class = Dancer::ModuleLoader\->class_from_setting(
\&        \*(AqDancer::Template\*(Aq => \*(Aqtiny\*(Aq,
\&    );
\&
\&    # class == \*(AqDancer::Template::Tiny
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Alexis Sukrieh
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2009\-2010 Alexis Sukrieh.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
