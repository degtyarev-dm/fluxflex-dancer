.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dancer::Tutorial 3"
.TH Dancer::Tutorial 3 "2011-07-07" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer::Tutorial \- An example to get you dancing
.SH "What is Dancer?"
.IX Header "What is Dancer?"
Dancer is a \*(L"micro\*(R" web framework which is modeled after a Ruby framework called Sinatra <http://www.sinatrarb.com>
that constructs web applications by building a list of \s-1HTTP\s0 verbs, URLs (called routes) and methods to handle 
that type of traffic to that specific \s-1URL\s0.
.PP
.Vb 1
\&  use Dancer;
\&
\&  get \*(Aq/\*(Aq => sub {
\&        return \*(AqHello World!\*(Aq;
\&  };
\&
\&  start;
.Ve
.PP
This example shows a single \s-1HTTP\s0 verb \*(L"\s-1GET\s0\*(R" followed by the root \s-1URL\s0 \*(L"/\*(R" and an anonymous subroutine which returns
the string \f(CW"Hello World!"\fR  If you were to run this example, it would display \*(L"Hello World!\*(R" when you point your
browser at <http://localhost:3000>.
.SH "How about a little more involved example?"
.IX Header "How about a little more involved example?"
That's the reason I wrote this tutorial.  While I was investigating some Python web frameworks like Flask <http://flask.pocoo.org/>
or Bottle <http://bottle.paws.de/docs/dev/index.html> I enjoyed the way they explained step by step how to build an example application
which was a little more involved that a trivial example.
.PP
Using the
Flaskr <http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/> sample
application as my inspiration (\s-1OK\s0, shamelessly plagiarised) I
translated that application to the Dancer framework so I could better understand how Dancer worked. (I'm learning
it too!)
.PP
So \*(L"Dancr\*(R" was born.
.PP
Dancr is a simple \*(L"micro\*(R" blog which uses the SQLite <http://www.sqlite.org> database engine for simplicity's sake.
.SH "Required perl modules"
.IX Header "Required perl modules"
Obviously you need Dancer.  You also need the Template Toolkit, File::Slurp, and DBD::SQLite.
These all can be installed using your \s-1CPAN\s0 client, as in:
.PP
.Vb 1
\&  cpan Dancer Template File::Slurp DBD::SQLite
.Ve
.SH "The database"
.IX Header "The database"
We're not going to spend a lot of time on the database, as it's not really the point of this particular
tutorial.
.PP
.Vb 5
\&  create table if not exists entries (
\&    id integer primary key autoincrement,
\&    title string not null,
\&    text string not null
\&  );
.Ve
.PP
Here we have a single table with three columns: id, title, and text.  The 'id' field is the primary key and will
automatically get an \s-1ID\s0 assigned by the database engine when a row is inserted.
.PP
We want our application to initialize the database automatically for us when we start it, so open your favorite
text editor <http://www.vim.org> and create a file called 'dancr.pl'.  We're going to put the following subroutines
in that file:
.PP
.Vb 3
\&  sub connect_db {
\&    my $dbh = DBI\->connect("dbi:SQLite:dbname=".setting(\*(Aqdatabase\*(Aq)) or
\&       die $DBI::errstr;
\&
\&    return $dbh;
\&  }
\&
\&  sub init_db {
\&    my $db = connect_db();
\&    my $schema = read_file(\*(Aq./schema.sql\*(Aq);
\&    $db\->do($schema) or die $db\->errstr;
\&  }
.Ve
.PP
Nothing too fancy in here, I hope. Standard \s-1DBI\s0 except for the \f(CW\*(C`setting(\*(Aqdatabase\*(Aq)\*(C'\fR thing \- more on that in a bit. 
For now, just assume that the expression evaluates to file location for the database file.
.PP
(Note that you may want to look at the Dancer::Plugin::Database module for an
easy way to configure and manage database connections for your Dancer apps, but
the above will suffice for this tutorial.)
.SH "Our first route handler"
.IX Header "Our first route handler"
Let's tackle our first route handler now, the one for the root \s-1URL\s0 '/'. This is what it looks like:
.PP
.Vb 11
\&  get \*(Aq/\*(Aq => sub {
\&    my $db = connect_db();
\&    my $sql = \*(Aqselect id, title, text from entries order by id desc\*(Aq;
\&    my $sth = $db\->prepare($sql) or die $db\->errstr;
\&    $sth\->execute or die $sth\->errstr;
\&    template \*(Aqshow_entries.tt\*(Aq, { 
\&       \*(Aqmsg\*(Aq => get_flash(),
\&       \*(Aqadd_entry_url\*(Aq => uri_for(\*(Aq/add\*(Aq),
\&       \*(Aqentries\*(Aq => $sth\->fetchall_hashref(\*(Aqid\*(Aq),
\&    };
\&  };
.Ve
.PP
As you can see, the handler is created by specifying the \s-1HTTP\s0 verb 'get' and
the \s-1URL\s0 to match, '/' and finally a subroutine to do something once those
conditions have been satisfied.  Something you might not notice right away is
the semicolon at the end of the route handler.  Since the subroutine actually
is a coderef, it requires a semicolon.
.PP
Let's take a closer look at the subroutine.  The first few lines are standard
\&\s-1DBI\s0. The only new concept as part of Dancer is that \f(CW\*(C`template\*(C'\fR directive at
the end of the handler.  That tells Dancer to process the output through one of
its templating engines.  In this case, we're using Template Toolkit
which offers a lot more flexibility than the simple default Dancer template
engine.
.PP
Templates all go into the \f(CW\*(C`views/\*(C'\fR directory. Optionally, you can create a
\&\*(L"layout\*(R" template which provides a consistent look and feel for all of your
views.  We'll construct our own layout template cleverly named \fImain.tt\fR a
little later in this tutorial.
.PP
What's going on with the hashref as the second argument to the template
directive?  Those are all of the parameters we want to pass into our template.
We have a \f(CW\*(C`msg\*(C'\fR field which displays a message to the user when an event
happens like a new entry is posted, or the user logs in or out.  It's called a
\&\*(L"flash\*(R" message because we only want to display it one time, not every time the
/ \s-1URL\s0 is rendered.
.PP
The \f(CW\*(C`uri_for\*(C'\fR directive tells Dancer to provide a \s-1URI\s0 for that specific route,
in this case, it is the route to post a new entry into the database.  You might
ask why we don't simply hardcode the \f(CW\*(C`/add\*(C'\fR \s-1URI\s0 in our application or
templates.  The best reason \fBnot\fR to do that is because it removes a layer of
flexibility on where to \*(L"mount\*(R" the web application. Although the application
is coded to use the root \s-1URL\s0 \f(CW\*(C`/\*(C'\fR it might be better in the future to locate it
under its own \s-1URL\s0 route (maybe \f(CW\*(C`/dancr\*(C'\fR?) \- at that point we'd have to go
through our application and the templates and update the URLs and hope we
didn't miss any of them.  By using the \f(CW\*(C`uri_for\*(C'\fR Dancer method, we can easily
load the application wherever we like and not have to modify the application at
all.
.PP
Finally, the \f(CW\*(C`entries\*(C'\fR field contains a hashref with the results from our
database query.  Those results will be rendered in the template itself, so we
just pass them in.
.PP
So what does the \fIshow_entries.tt\fR template look like? This:
.PP
.Vb 10
\&  <% IF session.logged_in %>
\&    <form action="<% add_entry_url %>" method=post class=add\-entry>
\&      <dl>
\&        <dt>Title:
\&        <dd><input type=text size=30 name=title>
\&        <dt>Text:
\&        <dd><textarea name=text rows=5 cols=40></textarea>
\&        <dd><input type=submit value=Share>
\&      </dl>
\&    </form>
\&  <% END %>
\&  <ul class=entries>
\&  <% IF entries.size %>
\&    <% FOREACH id IN entries.keys.nsort %>
\&      <li><h2><% entries.$id.title %></h2><% entries.$id.text %>
\&    <% END %>
\&  <% ELSE %>
\&    <li><em>Unbelievable.  No entries here so far</em>
\&  <% END %>
\&  </ul>
.Ve
.PP
Again, since this isn't a tutorial specifically about Template Toolkit, I'm
going to gloss over the syntax here and just point out the section which starts
with \f(CW\*(C`<ul class=entries>\*(C'\fR \- this is the section where the database
query results are displayed.  You can also see at the very top some discussion
about a session \- more on that soon.
.SH "Other HTTP verbs"
.IX Header "Other HTTP verbs"
There are 8 defined \s-1HTTP\s0 verbs defined in \s-1RFC\s0
2616 <http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9>: \s-1OPTIONS\s0, \s-1GET\s0,
\&\s-1HEAD\s0, \s-1POST\s0, \s-1PUT\s0, \s-1DELETE\s0, \s-1TRACE\s0, \s-1CONNECT\s0.  Of these, the majority of web
applications focus on the verbs which closely map to the \s-1CRUD\s0 (Create,
Retrieve, Update, Delete) operations most database driven applications need to
implement.
.PP
Dancer currently supports \s-1GET\s0, \s-1PUT\s0, \s-1POST\s0, \s-1DELETE\s0, \s-1OPTIONS\s0 which map to
Retrieve, Update, Create, Delete respectively.  Let's take a look now at the
\&\f(CW\*(C`/add\*(C'\fR route handler which handles a \s-1POST\s0 operation.
.PP
.Vb 4
\&  post \*(Aq/add\*(Aq => sub {
\&     if ( not session(\*(Aqlogged_in\*(Aq) ) {
\&        send_error("Not logged in", 401);
\&     }
\&
\&     my $db = connect_db();
\&     my $sql = \*(Aqinsert into entries (title, text) values (?, ?)\*(Aq;
\&     my $sth = $db\->prepare($sql) or die $db\->errstr;
\&     $sth\->execute(params\->{\*(Aqtitle\*(Aq}, params\->{\*(Aqtext\*(Aq}) or die $sth\->errstr;
\&
\&     set_flash(\*(AqNew entry posted!\*(Aq);
\&     redirect \*(Aq/\*(Aq;
\&  };
.Ve
.PP
As before, the \s-1HTTP\s0 verb begins the handler, followed by the route, and a
subroutine to do something \- in this case, it will insert a new entry into the
database.
.PP
The first check in the subroutine is the make sure the user sending the data is
logged in. If not, the application sends back an error and stops processing.
Otherwise, we have standard \s-1DBI\s0 stuff. Let me insert (heh, heh) a blatant plug
here for always, always using parameterized INSERTs in your application \s-1SQL\s0
statements.  It's the only way to be sure your application won't be vulnerable
to \s-1SQL\s0 injection. (See http://www.bobby\-tables.com <http://www.bobby-tables.com> for correct \s-1INSERT\s0
examples in multiple languages.) Here we're using the \f(CW\*(C`params\*(C'\fR convenience
method to pull in the parameters in the current \s-1HTTP\s0 request. (You can see the
\&'title' and 'text' form parameters in the \fIshow_entries.tt\fR template above.)
Those values are inserted into the database, then we set a flash message for
the user and redirect her back to the root \s-1URL\s0.
.PP
It's worth mentioning that the \*(L"flash message\*(R" is not part of Dancer, but a
part of this specific application.
.SH "Logins and sessions"
.IX Header "Logins and sessions"
Dancer comes with a simple in-memory session manager out of the box.  It
supports a bunch of other session engines including \s-1YAML\s0, memcached, browser
cookies and others.  For this application we're going to stick with the
in-memory model which works great for development and tutorials, but won't
persist across server restarts or scale very well in \*(L"real world\*(R" production
scenarios.
.SS "Configuration options"
.IX Subsection "Configuration options"
To use sessions in our application, we have to tell Dancer to activate the
session handler and initialize a session manager.  To do that, we add some
configuration directives toward the top of our dancr.pl file.  But there are
more options than just the session engine we want to set.
.PP
.Vb 7
\&  set \*(Aqsession\*(Aq      => \*(AqSimple\*(Aq;
\&  set \*(Aqtemplate\*(Aq     => \*(Aqtemplate_toolkit\*(Aq;
\&  set \*(Aqlogger\*(Aq       => \*(Aqconsole\*(Aq;
\&  set \*(Aqlog\*(Aq          => \*(Aqdebug\*(Aq;
\&  set \*(Aqshow_errors\*(Aq  => 1;
\&  set \*(Aqstartup_info\*(Aq => 1;
\&  set \*(Aqwarnings\*(Aq     => 1;
.Ve
.PP
Hopefully these are fairly self-explanatory. We want the Simple session engine,
the Template Toolkit template engine, logging enabled (at the 'debug' level
with output to the console instead of a file), we want to show errors to the
web browser, log access attempts and log Dancer warnings (instead of silently
ignoring them)
.PP
In a more sophisticated application you would want to put these configuration
options into a \s-1YAML\s0 file, but for this tutorial, we're going to keep it simple.
Dancer also supports the notion of application environments meaning you can
create a configuration file for your development instance, and another config
file for the production environment (with things like debugging and showing
errors disabled perhaps.) Dancer also doesn't impose any limits on what
parameters you can set using the \f(CW\*(C`set\*(C'\fR syntax.  For this application we're
going to embed our single username and password into the application itself.
.PP
.Vb 2
\&  set \*(Aqusername\*(Aq => \*(Aqadmin\*(Aq;
\&  set \*(Aqpassword\*(Aq => \*(Aqpassword\*(Aq;
.Ve
.PP
Hopefully no one will ever guess our clever password!  Obviously, you will want
a more sophisticated user authentication scheme in any sort of non-tutorial
application but this is good enough for our purposes.
.SS "Logging in"
.IX Subsection "Logging in"
Now that Dancr is configured to handle sessions, let's take a look at the \s-1URL\s0
handler for the \f(CW\*(C`/login\*(C'\fR route.
.PP
.Vb 2
\&  any [\*(Aqget\*(Aq, \*(Aqpost\*(Aq] => \*(Aq/login\*(Aq => sub {
\&     my $err;
\&
\&     if ( request\->method() eq "POST" ) {
\&       # process form input
\&       if ( params\->{\*(Aqusername\*(Aq} ne setting(\*(Aqusername\*(Aq) ) {
\&         $err = "Invalid username";
\&       }
\&       elsif ( params\->{\*(Aqpassword\*(Aq} ne setting(\*(Aqpassword\*(Aq) ) {
\&         $err = "Invalid password";
\&       }
\&       else {
\&         session \*(Aqlogged_in\*(Aq => true;
\&         set_flash(\*(AqYou are logged in.\*(Aq);
\&         return redirect \*(Aq/\*(Aq;
\&       }
\&    }
\&
\&    # display login form
\&    template \*(Aqlogin.tt\*(Aq, { 
\&      \*(Aqerr\*(Aq => $err,
\&    };
\&  };
.Ve
.PP
This is the first handler which accepts two different verb types, a \s-1GET\s0 for a
human browsing to the \s-1URL\s0 and a \s-1POST\s0 for the browser to submit the user's input
to the web application.  Since we're handling two different verbs, we check to
see what verb is in the request.  If it's \fBnot\fR a \s-1POST\s0, we drop down to the
\&\f(CW\*(C`template\*(C'\fR directive and display the \fIlogin.tt\fR template.
.PP
.Vb 11
\&  <h2>Login</h2>
\&  <% IF err %><p class=error><strong>Error:</strong> <% err %><% END %>
\&  <form action="<% login_url %>" method=post>
\&    <dl>
\&      <dt>Username:
\&      <dd><input type=text name=username>
\&      <dt>Password:
\&      <dd><input type=password name=password>
\&      <dd><input type=submit value=Login>
\&    </dl>
\&  </form>
.Ve
.PP
This is even simpler than our \fIshow_entries.tt\fR template \- but wait \- there's
a \f(CW\*(C`login_url\*(C'\fR template parameter and we're only passing in the \f(CW\*(C`err\*(C'\fR
parameter. Where's the missing parameter?  It's being generated and sent to the
template in a \f(CW\*(C`before_template\*(C'\fR directive \- we'll come back to that in a
moment or two.
.PP
So the user fills out the \fIlogin.tt\fR template and submits it back to the
\&\f(CW\*(C`/login\*(C'\fR route handler.  We now check the user input against our application
settings and if they're incorrect, we alert the user, otherwise the application
starts a session and sets the \f(CW\*(C`logged_in\*(C'\fR session parameter to the \f(CW\*(C`true()\*(C'\fR
value. Dancer exports both a \f(CW\*(C`true()\*(C'\fR and \f(CW\*(C`false()\*(C'\fR convenience method which
we use here.  After that, it's another flash message and back to the root \s-1URL\s0
handler.
.SS "Logging out"
.IX Subsection "Logging out"
And finally, we need a way to clear our user's session with the customary
logout procedure.
.PP
.Vb 5
\&  get \*(Aq/logout\*(Aq => sub {
\&     session\->destroy;
\&     set_flash(\*(AqYou are logged out.\*(Aq);
\&     redirect \*(Aq/\*(Aq;
\&  };
.Ve
.PP
\&\f(CW\*(C`session\->destroy;\*(C'\fR is Dancer's way to remove a stored session.  We notify
the user she is logged out and route her back to the root \s-1URL\s0 once again.
.SH "Layout and static files"
.IX Header "Layout and static files"
We still have a missing puzzle piece or two.  First, how can we use Dancer to
serve our \s-1CSS\s0 stylesheet? Second, where are flash messages displayed? Third,
what about the \f(CW\*(C`before_template\*(C'\fR directive?
.SS "Serving static files"
.IX Subsection "Serving static files"
In Dancer, static files should go into the \f(CW\*(C`public/\*(C'\fR directory, but in the
application be sure to omit the \f(CW\*(C`public/\*(C'\fR element from the path.  For example,
the stylesheet for Dancr lives in \f(CW\*(C`dancr/public/css/style.css\*(C'\fR but is served
from <http://localhost:3000/css/style.css>.
.PP
If you wanted to build a mostly static web site you could simply write route
handlers like this one:
.PP
.Vb 3
\&  get \*(Aq/\*(Aq => sub {
\&     send_file \*(Aqindex.html\*(Aq;
\&  };
.Ve
.PP
where index.html would live in your \f(CW\*(C`public/\*(C'\fR directory.
.PP
\&\f(CW\*(C`send_file\*(C'\fR does exactly what it says: it loads a static file, then sends the
contents of that file to the user.
.SS "Layouts"
.IX Subsection "Layouts"
I mentioned near the beginning of this tutorial that it is possible to create a
\&\f(CW\*(C`layout\*(C'\fR template. In Dancr, that layout is called \f(CW\*(C`main\*(C'\fR and it's set up by
putting in a directive like this:
.PP
.Vb 1
\&  set layout => \*(Aqmain\*(Aq;
.Ve
.PP
near the top of your web application.  What this tells Dancer's template engine
is that it should look for a file called \fImain.tt\fR in \f(CW\*(C`dancr/views/layouts/\*(C'\fR
and insert the calls from the \f(CW\*(C`template\*(C'\fR directive into a template parameter
called \f(CW\*(C`content\*(C'\fR.
.PP
For this web application, the layout template looks like this.
.PP
.Vb 10
\&  <!doctype html>
\&  <html>
\&  <head>
\&    <title>Dancr</title>
\&    <link rel=stylesheet type=text/css href="<% css_url %>">
\&  </head>
\&  <body>
\&    <div class=page>
\&    <h1>Dancr</h1>
\&       <div class=metanav>
\&       <% IF not session.logged_in %>
\&         <a href="<% login_url %>">log in</a>
\&       <% ELSE %>
\&         <a href="<% logout_url %>">log out</a>
\&       <% END %>
\&    </div>
\&    <% IF msg %>
\&      <div class=flash> <% msg %> </div>
\&    <% END %>
\&    <% content %>
\&  </div>
\&  </body>
\&  </html>
.Ve
.PP
Aha! You now see where the flash message \f(CW\*(C`msg\*(C'\fR parameter gets rendered. You
can also see where the content from the specific route handlers is inserted
(the fourth line from the bottom in the \f(CW\*(C`content\*(C'\fR template parameter.)
.PP
But what about all those other \f(CW*_url\fR template parameters?
.ie n .SS "Using ""before_template"""
.el .SS "Using \f(CWbefore_template\fP"
.IX Subsection "Using before_template"
Dancer has a way to manipulate the template parameters before they're passed to
the engine for processing. It's \f(CW\*(C`before_template\*(C'\fR.  Using this directive, you
can generate and set the URIs for the \f(CW\*(C`/login\*(C'\fR and \f(CW\*(C`/logout\*(C'\fR route handlers
and the \s-1URI\s0 for the stylesheet. This is handy for situations like this where
there are values which are re-used consistently across all (or most) templates.
This cuts down on code-duplication and makes your app easier to maintain over
time since you only need to update the values in this one place instead of
everywhere you render a template.
.PP
.Vb 2
\&  before_template sub {
\&     my $tokens = shift;
\&        
\&     $tokens\->{\*(Aqcss_url\*(Aq} = request\->base . \*(Aqcss/style.css\*(Aq;
\&     $tokens\->{\*(Aqlogin_url\*(Aq} = uri_for(\*(Aq/login\*(Aq);
\&     $tokens\->{\*(Aqlogout_url\*(Aq} = uri_for(\*(Aq/logout\*(Aq);
\&  };
.Ve
.PP
Here again I'm using \f(CW\*(C`uri_for\*(C'\fR instead of hardcoding the routes.  This code
block is executed before any of the templates are processed so that the
template parameters have the appropriate values before being rendered.
.SH "Putting it all together"
.IX Header "Putting it all together"
Here's the complete dancr.pl script from start to finish.
.PP
.Vb 5
\& use Dancer;
\& use DBI;
\& use File::Spec;
\& use File::Slurp;
\& use Template;
\& 
\& set \*(Aqdatabase\*(Aq     => File::Spec\->catfile(File::Spec\->tmpdir(), \*(Aqdancr.db\*(Aq);
\& set \*(Aqsession\*(Aq      => \*(AqSimple\*(Aq;
\& set \*(Aqtemplate\*(Aq     => \*(Aqtemplate_toolkit\*(Aq;
\& set \*(Aqlogger\*(Aq       => \*(Aqconsole\*(Aq;
\& set \*(Aqlog\*(Aq          => \*(Aqdebug\*(Aq;
\& set \*(Aqshow_errors\*(Aq  => 1;
\& set \*(Aqstartup_info\*(Aq => 1;
\& set \*(Aqwarnings\*(Aq     => 1;
\& set \*(Aqusername\*(Aq     => \*(Aqadmin\*(Aq;
\& set \*(Aqpassword\*(Aq     => \*(Aqpassword\*(Aq;
\& set \*(Aqlayout\*(Aq       => \*(Aqmain\*(Aq;
\& 
\& my $flash;
\& 
\& sub set_flash {
\&        my $message = shift;
\& 
\&        $flash = $message;
\& }
\& 
\& sub get_flash {
\& 
\&        my $msg = $flash;
\&        $flash = "";
\& 
\&        return $msg;
\& }
\& 
\& sub connect_db {
\&        my $dbh = DBI\->connect("dbi:SQLite:dbname=".setting(\*(Aqdatabase\*(Aq)) or
\&                die $DBI::errstr;
\& 
\&        return $dbh;
\& }
\& 
\& sub init_db {
\&        my $db = connect_db();
\&        my $schema = read_file(\*(Aq./schema.sql\*(Aq);
\&        $db\->do($schema) or die $db\->errstr;
\& }
\& 
\& before_template sub {
\&        my $tokens = shift;
\&        
\&        $tokens\->{\*(Aqcss_url\*(Aq} = request\->base . \*(Aqcss/style.css\*(Aq;
\&        $tokens\->{\*(Aqlogin_url\*(Aq} = uri_for(\*(Aq/login\*(Aq);
\&        $tokens\->{\*(Aqlogout_url\*(Aq} = uri_for(\*(Aq/logout\*(Aq);
\& };
\& 
\& get \*(Aq/\*(Aq => sub {
\&        my $db = connect_db();
\&        my $sql = \*(Aqselect id, title, text from entries order by id desc\*(Aq;
\&        my $sth = $db\->prepare($sql) or die $db\->errstr;
\&        $sth\->execute or die $sth\->errstr;
\&        template \*(Aqshow_entries.tt\*(Aq, { 
\&                \*(Aqmsg\*(Aq => get_flash(),
\&                \*(Aqadd_entry_url\*(Aq => uri_for(\*(Aq/add\*(Aq),
\&                \*(Aqentries\*(Aq => $sth\->fetchall_hashref(\*(Aqid\*(Aq),
\&        };
\& };
\& 
\& post \*(Aq/add\*(Aq => sub {
\&        if ( not session(\*(Aqlogged_in\*(Aq) ) {
\&                send_error("Not logged in", 401);
\&        }
\& 
\&        my $db = connect_db();
\&        my $sql = \*(Aqinsert into entries (title, text) values (?, ?)\*(Aq;
\&        my $sth = $db\->prepare($sql) or die $db\->errstr;
\&        $sth\->execute(params\->{\*(Aqtitle\*(Aq}, params\->{\*(Aqtext\*(Aq}) or die $sth\->errstr;
\& 
\&        set_flash(\*(AqNew entry posted!\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\& };
\& 
\& any [\*(Aqget\*(Aq, \*(Aqpost\*(Aq] => \*(Aq/login\*(Aq => sub {
\&        my $err;
\& 
\&        if ( request\->method() eq "POST" ) {
\&                # process form input
\&                if ( params\->{\*(Aqusername\*(Aq} ne setting(\*(Aqusername\*(Aq) ) {
\&                        $err = "Invalid username";
\&                }
\&                elsif ( params\->{\*(Aqpassword\*(Aq} ne setting(\*(Aqpassword\*(Aq) ) {
\&                        $err = "Invalid password";
\&                }
\&                else {
\&                        session \*(Aqlogged_in\*(Aq => true;
\&                        set_flash(\*(AqYou are logged in.\*(Aq);
\&                        return redirect \*(Aq/\*(Aq;
\&                }
\&        }
\&
\&        # display login form
\&        template \*(Aqlogin.tt\*(Aq, { 
\&                \*(Aqerr\*(Aq => $err,
\&        };
\&
\& };
\&
\& get \*(Aq/logout\*(Aq => sub {
\&        session\->destroy;
\&        set_flash(\*(AqYou are logged out.\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\& };
\&
\& init_db();
\& start;
.Ve
.SH "Advanced route moves"
.IX Header "Advanced route moves"
There's a lot more to route matching than shown here. For example, you can
match routes with regular expressions, or you can match pieces of a route like
\&\f(CW\*(C`/hello/:name\*(C'\fR where the \f(CW\*(C`:name\*(C'\fR piece magically turns into a named parameter
in your handler for manipulation.
.SH "Happy dancing!"
.IX Header "Happy dancing!"
I hope this effort has been helpful and interesting enough to get you exploring
Dancer on your own. The framework is still under heavy development but it's
definitely mature enough to use in a production project.  Additionally, there
are now a lot of great Dancer plugins which extend and enhance the capabilities
of the the platform.
.PP
Happy dancing!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
http://perldancer.org
.IP "\(bu" 4
http://github.com/sukria/Dancer
.IP "\(bu" 4
http://search.cpan.org/~sukria/Dancer/lib/Dancer/Plugins.pod
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by Mark R. Allen.
.PP
This is free software; you can redistribute it and/or modify it under the terms of either the Artistic License 2.0
or the \s-1GNU\s0 Public License version 2.
.PP
The \s-1CSS\s0 stylesheet is copied verbatim from the Flaskr example application and is subject to their license:
.PP
Copyright (c) 2010 by Armin Ronacher and contributors.
.PP
Some rights reserved.
.PP
Redistribution and use in source and binary forms of the software as well
as documentation, with or without modification, are permitted provided
that the following conditions are met:
.IP "\(bu" 4
Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
.IP "\(bu" 4
Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided
with the distribution.
.IP "\(bu" 4
The names of the contributors may not be used to endorse or
promote products derived from this software without specific
prior written permission.
.PP
\&\s-1THIS\s0 \s-1SOFTWARE\s0 \s-1AND\s0 \s-1DOCUMENTATION\s0 \s-1IS\s0 \s-1PROVIDED\s0 \s-1BY\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND\s0
\&\s-1CONTRIBUTORS\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1AND\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1BUT\s0
\&\s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0
A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1ARE\s0 \s-1DISCLAIMED\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1OWNER\s0
\&\s-1OR\s0 \s-1CONTRIBUTORS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1DIRECT\s0, \s-1INDIRECT\s0, \s-1INCIDENTAL\s0, \s-1SPECIAL\s0,
\&\s-1EXEMPLARY\s0, \s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 (\s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0,
\&\s-1PROCUREMENT\s0 \s-1OF\s0 \s-1SUBSTITUTE\s0 \s-1GOODS\s0 \s-1OR\s0 \s-1SERVICES\s0; \s-1LOSS\s0 \s-1OF\s0 \s-1USE\s0, \s-1DATA\s0, \s-1OR\s0
\&\s-1PROFITS\s0; \s-1OR\s0 \s-1BUSINESS\s0 \s-1INTERRUPTION\s0) \s-1HOWEVER\s0 \s-1CAUSED\s0 \s-1AND\s0 \s-1ON\s0 \s-1ANY\s0 \s-1THEORY\s0 \s-1OF\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1CONTRACT\s0, \s-1STRICT\s0 \s-1LIABILITY\s0, \s-1OR\s0 \s-1TORT\s0 (\s-1INCLUDING\s0
\&\s-1NEGLIGENCE\s0 \s-1OR\s0 \s-1OTHERWISE\s0) \s-1ARISING\s0 \s-1IN\s0 \s-1ANY\s0 \s-1WAY\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OF\s0 \s-1THIS\s0
\&\s-1SOFTWARE\s0 \s-1AND\s0 \s-1DOCUMENTATION\s0, \s-1EVEN\s0 \s-1IF\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0
\&\s-1DAMAGE\s0.
