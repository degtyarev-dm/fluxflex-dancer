.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dancer 3"
.TH Dancer 3 "2011-08-23" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer \- lightweight yet powerful web application framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    #!/usr/bin/perl
\&    use Dancer;
\&
\&    get \*(Aq/hello/:name\*(Aq => sub {
\&        return "Why, hello there " . param(\*(Aqname\*(Aq);
\&    };
\&
\&    dance;
.Ve
.PP
The above is a basic but functional web app created with Dancer.  If you want
to see more examples and get up and running quickly, check out the
Dancer::Introduction and the Dancer::Cookbook.  For examples on
deploying your Dancer applications, see Dancer::Deployment.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Dancer is a web application framework designed to be as effortless as possible
for the developer, taking care of the boring bits as easily as possible, yet
staying out of your way and letting you get on with writing your code.
.PP
Dancer aims to provide the simplest way for writing web applications, and
offers the flexibility to scale between a very simple lightweight web service
consisting of a few lines of code in a single file, all the way up to a more
complex fully-fledged web application with session support, templates for views
and layouts, etc.
.PP
If you don't want to write \s-1CGI\s0 scripts by hand, and find Catalyst too big or
cumbersome for your project, Dancer is what you need.
.PP
Dancer has few pre-requisites, so your Dancer webapps will be easy to deploy.
.PP
Dancer apps can be used with a an embedded web server (great for easy testing),
and can run under PSGI/Plack for easy deployment in a variety of webserver
environments.
.SH "MORE DOCUMENTATION"
.IX Header "MORE DOCUMENTATION"
This documentation describes all the exported symbols of Dancer. If you want
a quick start guide to discover the framework, you should look at
Dancer::Introduction, or Dancer::Tutorial to learn by example.
.PP
If you want to have specific examples of code for real-life problems, see the
Dancer::Cookbook.
.PP
If you want to see configuration examples of different deployment solutions
involving Dancer and Plack, see Dancer::Deployment.
.PP
You can find out more about the many useful plugins available for Dancer in
Dancer::Plugins.
.SH "EXPORTS"
.IX Header "EXPORTS"
By default, \f(CW\*(C`use Dancer\*(C'\fR exports all the functions below plus sets up
your app.  You can control the exporting through the normal
Exporter mechanism.  For example:
.PP
.Vb 2
\&    # Just export the route controllers
\&    use Dancer qw(before after get post);
\&
\&    # Export everything but pass to avoid clashing with Test::More
\&    use Test::More;
\&    use Dancer qw(!pass);
.Ve
.PP
There are also some special tags to control exports and behaviour.
.SS ":moose"
.IX Subsection ":moose"
This will export everything except functions which clash with
Moose. Currently these are \f(CW\*(C`after\*(C'\fR and \f(CW\*(C`before\*(C'\fR.
.SS ":syntax"
.IX Subsection ":syntax"
This tells Dancer to just export symbols and not set up your app.
This is most useful for writing Dancer code outside of your main route
handler.
.SS ":tests"
.IX Subsection ":tests"
This will export everything except functions which clash with
commonly used testing modules. Currently these are \f(CW\*(C`pass\*(C'\fR.
.PP
It can be combined with other export pragmas. For example, while testing...
.PP
.Vb 2
\&    use Test::More;
\&    use Dancer qw(:syntax :tests);
\&
\&    # Test::Most also exports "set" and "any"
\&    use Test::Most;
\&    use Dancer qw(:syntax :tests !set !any);
\&
\&    # Alternatively, if you want to use Dancer\*(Aqs set and any...
\&    use Test::Most qw(!set !any);
\&    use Dancer qw(:syntax :tests);
.Ve
.SS ":script"
.IX Subsection ":script"
This will export all the keywords, and will also load the configuration.
.PP
This is useful when you want to use your Dancer application from a script.
.PP
.Vb 3
\&    use MyApp;
\&    use Dancer \*(Aq:script\*(Aq;
\&    MyApp::schema(\*(AqDBSchema\*(Aq)\->deploy();
.Ve
.PP
By default, the warnings pragma will also be exported, meaning your
app/script will be running under \f(CW\*(C`use warnings\*(C'\fR.  If you do not want this, set
the import_warnings setting to a false value.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "after"
.IX Subsection "after"
Add a hook at the \fBafter\fR position:
.PP
.Vb 4
\&    after sub {
\&        my $response = shift;
\&        # do something with request
\&    };
.Ve
.PP
The anonymous function which is given to \f(CW\*(C`after\*(C'\fR will be executed after
having executed a route.
.PP
You can define multiple after filters, using the \f(CW\*(C`after\*(C'\fR helper as
many times as you wish; each filter will be executed, in the order you added
them.
.SS "any"
.IX Subsection "any"
Defines a route for multiple \s-1HTTP\s0 methods at once:
.PP
.Vb 3
\&    any [\*(Aqget\*(Aq, \*(Aqpost\*(Aq] => \*(Aq/myaction\*(Aq => sub {
\&        # code
\&    };
.Ve
.PP
Or even, a route handler that would match any \s-1HTTP\s0 methods:
.PP
.Vb 3
\&    any \*(Aq/myaction\*(Aq => sub {
\&        # code
\&    };
.Ve
.SS "before"
.IX Subsection "before"
Defines a before filter:
.PP
.Vb 3
\&    before sub {
\&        # do something with request, vars or params
\&    };
.Ve
.PP
The anonymous function given to \f(CW\*(C`before\*(C'\fR will be executed before executing a
route handler to handle the request.
.PP
If the function modifies the request's \f(CW\*(C`path_info\*(C'\fR or \f(CW\*(C`method\*(C'\fR, a new
search for a matching route is performed and the filter is re-executed.
Considering that this can lead to an infinite loop, this mechanism
is stopped after 10 times with an exception.
.PP
The before filter can set a response with a redirection code (either
301 or 302): in this case the matched route (if any) will be ignored and the
redirection will be performed immediately.
.PP
You can define multiple before filters, using the \f(CW\*(C`before\*(C'\fR helper as
many times as you wish; each filter will be executed in the order you added
them.
.SS "before_template"
.IX Subsection "before_template"
Defines a before_template filter:
.PP
.Vb 3
\&    before_template sub {
\&        my $tokens = shift;
\&        # do something with request, vars or params
\&        
\&        # for example, adding a token to the template
\&        $tokens\->{token_name} = "some value";
\&    };
.Ve
.PP
The anonymous function which is given to \f(CW\*(C`before_template\*(C'\fR will be executed
before sending data and tokens to the template. Receives a HashRef of the
tokens that will be inserted into the template.
.PP
This filter works as the \f(CW\*(C`before\*(C'\fR and \f(CW\*(C`after\*(C'\fR filter.
.PP
Now the preferred way for this is to use \f(CW\*(C`hook\*(C'\fRs (namely, the
\&\f(CW\*(C`before_template\*(C'\fR one). Check \f(CW\*(C`hook\*(C'\fR documentation below.
.SS "cookies"
.IX Subsection "cookies"
Accesses cookies values, it returns a HashRef of Dancer::Cookie objects:
.PP
.Vb 4
\&    get \*(Aq/some_action\*(Aq => sub {
\&        my $cookie = cookies\->{name};
\&        return $cookie\->value;
\&    };
.Ve
.PP
In the case you have stored something else than a Scalar in your cookie:
.PP
.Vb 5
\&    get \*(Aq/some_action\*(Aq => sub {
\&        my $cookie = cookies\->{oauth};
\&        my %values = $cookie\->value;
\&        return ($values{token}, $values{token_secret});
\&    };
.Ve
.SS "cookie"
.IX Subsection "cookie"
Accesses a cookie value (or sets it). Note that this method will
eventually be preferred over \f(CW\*(C`set_cookie\*(C'\fR.
.PP
.Vb 3
\&    cookie lang => "fr\-FR";              # set a cookie and return its value
\&    cookie lang => "fr\-FR", expires => "2 hours";   # extra cookie info
\&    cookie "lang"                        # return a cookie value
.Ve
.PP
If your cookie value is a key/value \s-1URI\s0 string, like
.PP
.Vb 1
\&    token=ABC&user=foo
.Ve
.PP
\&\f(CW\*(C`cookie\*(C'\fR will only return the first part (\f(CW\*(C`token=ABC\*(C'\fR) if called in scalar context.
Use list context to fetch them all:
.PP
.Vb 1
\&    my @values = cookie "name";
.Ve
.SS "config"
.IX Subsection "config"
Accesses the configuration of the application:
.PP
.Vb 3
\&    get \*(Aq/appname\*(Aq => sub {
\&        return "This is " . config\->{appname};
\&    };
.Ve
.SS "content_type"
.IX Subsection "content_type"
Sets the \fBcontent-type\fR rendered, for the current route handler:
.PP
.Vb 2
\&    get \*(Aq/cat/:txtfile\*(Aq => sub {
\&        content_type \*(Aqtext/plain\*(Aq;
\&
\&        # here we can dump the contents of param(\*(Aqtxtfile\*(Aq)
\&    };
.Ve
.PP
You can use abbreviations for content types. For instance:
.PP
.Vb 2
\&    get \*(Aq/svg/:id\*(Aq => sub {
\&        content_type \*(Aqsvg\*(Aq;
\&
\&        # here we can dump the image with id param(\*(Aqid\*(Aq)
\&    };
.Ve
.PP
Note that if you want to change the default content-type for every route, you
have to change the \f(CW\*(C`content_type\*(C'\fR setting instead.
.SS "dance"
.IX Subsection "dance"
Alias for the \f(CW\*(C`start\*(C'\fR keyword.
.SS "debug"
.IX Subsection "debug"
Logs a message of debug level:
.PP
.Vb 1
\&    debug "This is a debug message";
.Ve
.PP
See Dancer::Logger for details on how to configure where log messages go.
.SS "dirname"
.IX Subsection "dirname"
Returns the dirname of the path given:
.PP
.Vb 1
\&    my $dir = dirname($some_path);
.Ve
.SS "engine"
.IX Subsection "engine"
Given a namespace, returns the current engine object
.PP
.Vb 3
\&    my $template_engine = engine \*(Aqtemplate\*(Aq;
\&    my $html = $template_engine\->apply_renderer(...);
\&    $template_engine\->apply_layout($html);
.Ve
.SS "error"
.IX Subsection "error"
Logs a message of error level:
.PP
.Vb 1
\&    error "This is an error message";
.Ve
.PP
See Dancer::Logger for details on how to configure where log messages go.
.SS "false"
.IX Subsection "false"
Constant that returns a false value (0).
.SS "forward"
.IX Subsection "forward"
Runs an internal redirect of the current request to another request. This helps
you avoid having to redirect the user using \s-1HTTP\s0 and set another request to your
application.
.PP
It effectively lets you chain routes together in a clean manner.
.PP
.Vb 2
\&    get qr{ /demo/articles/(.+) }x => sub {
\&        my ($article_id) = splat;
\&
\&        # you\*(Aqll have to implement this next sub yourself :)
\&        change_the_main_database_to_demo();
\&
\&        forward \*(Aq/articles/$article_id\*(Aq;
\&    };
.Ve
.PP
In the above example, the users that reach \fI/demo/articles/30\fR will actually
reach \fI/articles/30\fR but we've changed the database to demo before.
.PP
This is pretty cool because it lets us retain our paths and offer a demo
database by merely going to \fI/demo/...\fR.
.PP
You'll notice that in the example we didn't indicate whether it was \fB\s-1GET\s0\fR or
\&\fB\s-1POST\s0\fR. That is because \f(CW\*(C`forward\*(C'\fR chains the same type of route the user
reached. If it was a \fB\s-1GET\s0\fR, it will remain a \fB\s-1GET\s0\fR.
.PP
Broader functionality might be added in the future.
.PP
It is important to note that issuing a forward by itself does not exit and
forward immediately, forwarding is deferred until after the current route
or filter has been processed. To exit and forward immediately, use the return
function, e.g.
.PP
.Vb 4
\&    get \*(Aq/some/path => sub {
\&        if ($condition) {
\&            return forward \*(Aq/articles/$article_id\*(Aq;
\&        }
\&
\&        more_stuff();
\&    };
.Ve
.PP
You probably always want to use \f(CW\*(C`return\*(C'\fR with forward.
.PP
Note that forward doesn't parse \s-1GET\s0 arguments. So, you can't use
something like:
.PP
.Vb 1
\&     return forward \*(Aq/home?authorized=1\*(Aq;
.Ve
.PP
But \f(CW\*(C`forward\*(C'\fR supports an optional HashRef with parameters to be added
to the actual parameters:
.PP
.Vb 1
\&     return forward \*(Aq/home\*(Aq, { authorized => 1 };
.Ve
.PP
Finally, you can add some more options to the forward method, in a
third argument, also as a HashRef. That option is currently
only used to change the method of your request. Use with caution.
.PP
.Vb 1
\&    return forward \*(Aq/home\*(Aq, { auth => 1 }, { method => \*(AqPOST\*(Aq };
.Ve
.SS "from_dumper ($structure)"
.IX Subsection "from_dumper ($structure)"
Deserializes a Data::Dumper structure.
.ie n .SS "from_json ($structure, %options)"
.el .SS "from_json ($structure, \f(CW%options\fP)"
.IX Subsection "from_json ($structure, %options)"
Deserializes a \s-1JSON\s0 structure. Can receive optional arguments. Those arguments
are valid \s-1JSON\s0 arguments to change the behaviour of the default
\&\f(CW\*(C`JSON::from_json\*(C'\fR function.
.SS "from_yaml ($structure)"
.IX Subsection "from_yaml ($structure)"
Deserializes a \s-1YAML\s0 structure.
.ie n .SS "from_xml ($structure, %options)"
.el .SS "from_xml ($structure, \f(CW%options\fP)"
.IX Subsection "from_xml ($structure, %options)"
Deserializes a \s-1XML\s0 structure. Can receive optional arguments. These arguments
are valid XML::Simple arguments to change the behaviour of the default
\&\f(CW\*(C`XML::Simple::XMLin\*(C'\fR function.
.SS "get"
.IX Subsection "get"
Defines a route for \s-1HTTP\s0 \fB\s-1GET\s0\fR requests to the given path:
.PP
.Vb 3
\&    get \*(Aq/\*(Aq => sub {
\&        return "Hello world";
\&    }
.Ve
.PP
Note that a route to match \fB\s-1HEAD\s0\fR requests is automatically created as well.
.SS "halt"
.IX Subsection "halt"
Sets a response object with the content given.
.PP
When used as a return value from a filter, this breaks the execution flow and
renders the response immediately:
.PP
.Vb 5
\&    before sub {
\&        if ($some_condition) {
\&            return halt("Unauthorized");
\&        }
\&    };
\&
\&    get \*(Aq/\*(Aq => sub {
\&        "hello there";
\&    };
.Ve
.SS "headers"
.IX Subsection "headers"
Adds custom headers to responses:
.PP
.Vb 3
\&    get \*(Aq/send/headers\*(Aq, sub {
\&        headers \*(AqX\-Foo\*(Aq => \*(Aqbar\*(Aq, X\-Bar => \*(Aqfoo\*(Aq;
\&    }
.Ve
.SS "header"
.IX Subsection "header"
adds a custom header to response:
.PP
.Vb 3
\&    get \*(Aq/send/header\*(Aq, sub {
\&        header \*(Aqx\-my\-header\*(Aq => \*(Aqshazam!\*(Aq;
\&    }
.Ve
.PP
Note that it will overwrite the old value of the header, if any. To avoid that,
see \*(L"push_header\*(R".
.SS "push_header"
.IX Subsection "push_header"
Do the same as \f(CW\*(C`header\*(C'\fR, but allow for multiple headers with the same name.
.PP
.Vb 5
\&    get \*(Aq/send/header\*(Aq, sub {
\&        push_header \*(Aqx\-my\-header\*(Aq => \*(Aq1\*(Aq;
\&        push_header \*(Aqx\-my\-header\*(Aq => \*(Aq2\*(Aq;
\&        will result in two headers "x\-my\-header" in the response
\&    }
.Ve
.SS "hook"
.IX Subsection "hook"
Adds a hook at some position. For example :
.PP
.Vb 4
\&  hook before_serializer => sub {
\&    my $response = shift;
\&    $response\->content\->{generated_at} = localtime();
\&  };
.Ve
.PP
There can be multiple hooks assigned to a given position, and each will be
executed in order.
.PP
(For details on how to register new hooks from within plugins, see
Dancer::Hook.)
Supported \fBbefore\fR hooks (in order of execution):
.IP "before_deserializer" 4
.IX Item "before_deserializer"
This hook receives no arguments.
.Sp
.Vb 3
\&  hook before_deserializer => sub {
\&    ...
\&  };
.Ve
.IP "before_file_render" 4
.IX Item "before_file_render"
This hook receives as argument the path of the file to render.
.Sp
.Vb 4
\&  hook before_file_render => sub {
\&    my $path = shift;
\&    ...
\&  };
.Ve
.IP "before_error_init" 4
.IX Item "before_error_init"
This hook receives as argument a Dancer::Error object.
.Sp
.Vb 4
\&  hook before_error_init => sub {
\&    my $error = shift;
\&    ...
\&  };
.Ve
.IP "before_error_render" 4
.IX Item "before_error_render"
This hook receives as argument a Dancer::Error object.
.Sp
.Vb 3
\&  hook before_error_render => sub {
\&    my $error = shift;
\&  };
.Ve
.IP "before" 4
.IX Item "before"
This is an alias to \f(CW\*(C`before\*(C'\fR.
.Sp
This hook receives no arguments.
.Sp
.Vb 3
\&  before sub {
\&    ...
\&  };
.Ve
.Sp
is equivalent to
.Sp
.Vb 3
\&  hook before => sub {
\&    ...
\&  };
.Ve
.IP "before_template_render" 4
.IX Item "before_template_render"
This is an alias to 'before_template'.
.Sp
This hook receives as argument a HashRef, containing the tokens that
will be passed to the template. You can use it to add more tokens, or
delete some specific token.
.Sp
.Vb 5
\&  hook before_template_render => sub {
\&    my $tokens = shift;
\&    delete $tokens\->{user};
\&    $tokens\->{time} = localtime;
\&  };
.Ve
.Sp
is equivalent to
.Sp
.Vb 5
\&  hook before_template => sub {
\&    my $tokens = shift;
\&    delete $tokens\->{user};
\&    $tokens\->{time} = localtime;
\&  };
.Ve
.IP "before_layout_render" 4
.IX Item "before_layout_render"
This hook receives two arguments. The first one is a HashRef containing the
tokens. The second is a ScalarRef representing the content of the template.
.Sp
.Vb 4
\&  hook before_layout_render => sub {
\&    my ($tokens, $html_ref) = @_;
\&    ...
\&  };
.Ve
.IP "before_serializer" 4
.IX Item "before_serializer"
This hook receives as argument a Dancer::Response object.
.Sp
.Vb 4
\&  hook before_serializer => sub {
\&    my $response = shift;
\&    $response\->content\->{start_time} = time();
\&  };
.Ve
.PP
Supported \fBafter\fR hooks (in order of execution):
.IP "after_deserializer" 4
.IX Item "after_deserializer"
This hook receives no arguments.
.Sp
.Vb 3
\&  hook after_deserializer => sub {
\&    ...
\&  };
.Ve
.IP "after_file_render" 4
.IX Item "after_file_render"
This hook receives as argument a Dancer::Response object.
.Sp
.Vb 3
\&  hook after_file_render => sub {
\&    my $response = shift;
\&  };
.Ve
.IP "after_template_render" 4
.IX Item "after_template_render"
This hook receives as argument a ScalarRef representing the content generated
by the template.
.Sp
.Vb 3
\&  hook after_template_render => sub {
\&    my $html_ref = shift;
\&  };
.Ve
.IP "after_layout_render" 4
.IX Item "after_layout_render"
This hook receives as argument a ScalarRef representing the content generated
by the layout
.Sp
.Vb 3
\&  hook after_layout_render => sub {
\&    my $html_ref = shift;
\&  };
.Ve
.IP "after" 4
.IX Item "after"
This is an alias for 'after'.
.Sp
This hook receives as argument a Dancer::Response object.
.Sp
.Vb 3
\&  hook after => sub {
\&    my $response = shift;
\&  };
.Ve
.Sp
This is equivalent to
.Sp
.Vb 3
\&  after sub {
\&    my $response = shift;
\&  };
.Ve
.IP "after_error_render" 4
.IX Item "after_error_render"
This hook receives as argument a Dancer::Response object.
.Sp
.Vb 3
\&  hook after_error_render => sub {
\&    my $response = shift;
\&  };
.Ve
.SS "layout"
.IX Subsection "layout"
This method is deprecated. Use \f(CW\*(C`set\*(C'\fR:
.PP
.Vb 1
\&    set layout => \*(Aquser\*(Aq;
.Ve
.SS "logger"
.IX Subsection "logger"
Deprecated. Use \f(CW\*(C`<set logger =\*(C'\fR 'console'>> to change current logger engine.
.SS "load"
.IX Subsection "load"
Loads one or more perl scripts in the current application's namespace. Syntactic
sugar around Perl's \f(CW\*(C`require\*(C'\fR:
.PP
.Vb 1
\&    load \*(AqUserActions.pl\*(Aq, \*(AqAdminActions.pl\*(Aq;
.Ve
.SS "load_app"
.IX Subsection "load_app"
Loads a Dancer package. This method sets the libdir to the current \f(CW\*(C`./lib\*(C'\fR
directory:
.PP
.Vb 4
\&    # if we have lib/Webapp.pm, we can load it like:
\&    load_app \*(AqWebapp\*(Aq;
\&    # or with options
\&    load_app \*(AqForum\*(Aq, prefix => \*(Aq/forum\*(Aq, settings => {foo => \*(Aqbar\*(Aq};
.Ve
.PP
Note that the package loaded using load_app \fBmust\fR import Dancer with the
\&\f(CW\*(C`:syntax\*(C'\fR option.
.PP
To load multiple apps repeat load_app:
.PP
.Vb 2
\&    load_app \*(Aqone\*(Aq;
\&    load_app \*(Aqtwo\*(Aq;
.Ve
.PP
The old way of loading multiple apps in one go (load_app 'one', 'two';) is
deprecated.
.SS "mime_type"
.IX Subsection "mime_type"
Deprecated. See \*(L"mime\*(R".
.SS "mime"
.IX Subsection "mime"
Shortcut to access the instance object of Dancer::MIME. You should
read the Dancer::MIME documentation for full details, but the most
commonly-used methods are summarized below:
.PP
.Vb 2
\&    # set a new mime type
\&    mime\->add_type( foo => \*(Aqtext/foo\*(Aq );
\&
\&    # set a mime type alias
\&    mime\->add_alias( f => \*(Aqfoo\*(Aq );
\&
\&    # get mime type for an alias
\&    my $m = mime\->for_name( \*(Aqf\*(Aq );
\&
\&    # get mime type for a file (based on extension)
\&    my $m = mime\->for_file( "foo.bar" );
\&
\&    # get current defined default mime type
\&    my $d = mime\->default;
\&
\&    # set the default mime type using config.yml
\&    # or using the set keyword
\&    set default_mime_type => \*(Aqtext/plain\*(Aq;
.Ve
.SS "params"
.IX Subsection "params"
\&\fIThis method should be called from a route handler\fR.
It's an alias for the Dancer::Request params accessor. It returns
an hash reference to all defined parameters. Check \f(CW\*(C`param\*(C'\fR bellow to access quickly to a single
parameter value.
.SS "param"
.IX Subsection "param"
\&\fIThis method should be called from a route handler\fR.
This method is an accessor to the parameters hash table.
.PP
.Vb 5
\&   post \*(Aq/login\*(Aq => sub {
\&       my $username = param "user";
\&       my $password = param "pass";
\&       # ...
\&   }
.Ve
.SS "pass"
.IX Subsection "pass"
\&\fIThis method should be called from a route handler\fR.
Tells Dancer to pass the processing of the request to the next
matching route.
.PP
You should always \f(CW\*(C`return\*(C'\fR after calling \f(CW\*(C`pass\*(C'\fR:
.PP
.Vb 6
\&    get \*(Aq/some/route\*(Aq => sub {
\&        if (...) {
\&            # we want to let the next matching route handler process this one
\&            return pass();
\&        }
\&    };
.Ve
.SS "path"
.IX Subsection "path"
Concatenates multiple paths together, without worrying about the underlying
operating system:
.PP
.Vb 1
\&    my $path = path(dirname($0), \*(Aqlib\*(Aq, \*(AqFile.pm\*(Aq);
.Ve
.PP
It also normalizes (cleans) the path aesthetically. It does not verify the
path exists.
.SS "post"
.IX Subsection "post"
Defines a route for \s-1HTTP\s0 \fB\s-1POST\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 3
\&    post \*(Aq/\*(Aq => sub {
\&        return "Hello world";
\&    }
.Ve
.SS "prefix"
.IX Subsection "prefix"
Defines a prefix for each route handler, like this:
.PP
.Vb 1
\&    prefix \*(Aq/home\*(Aq;
.Ve
.PP
From here, any route handler is defined to /home/*:
.PP
.Vb 1
\&    get \*(Aq/page1\*(Aq => sub {}; # will match \*(Aq/home/page1\*(Aq
.Ve
.PP
You can unset the prefix value:
.PP
.Vb 2
\&    prefix undef;
\&    get \*(Aq/page1\*(Aq => sub {}; will match /page1
.Ve
.PP
For a safer alternative you can use lexical prefix like this:
.PP
.Vb 2
\&    prefix \*(Aq/home\*(Aq => sub {
\&        ## Prefix is set to \*(Aq/home\*(Aq here
\&
\&        get ...;
\&        get ...;
\&    };
\&    ## prefix reset to the previous version here
.Ve
.PP
This makes it possible to nest prefixes:
.PP
.Vb 2
\&   prefix \*(Aq/home\*(Aq => sub {
\&       ## some routes
\&       
\&      prefix \*(Aq/private\*(Aq => sub {
\&         ## here we are under /home/private...
\&
\&         ## some more routes
\&      };
\&      ## back to /home
\&   };
\&   ## back to the root
.Ve
.PP
\&\fBNotice:\fR once you have a prefix set, do not add a caret to the regex:
.PP
.Vb 3
\&    prefix \*(Aq/foo\*(Aq;
\&    get qr{^/bar} => sub { ... } # BAD BAD BAD
\&    get qr{/bar}  => sub { ... } # Good!
.Ve
.SS "del"
.IX Subsection "del"
Defines a route for \s-1HTTP\s0 \fB\s-1DELETE\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 1
\&    del \*(Aq/resource\*(Aq => sub { ... };
.Ve
.SS "options"
.IX Subsection "options"
Defines a route for \s-1HTTP\s0 \fB\s-1OPTIONS\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 1
\&    options \*(Aq/resource\*(Aq => sub { ... };
.Ve
.SS "put"
.IX Subsection "put"
Defines a route for \s-1HTTP\s0 \fB\s-1PUT\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 1
\&    put \*(Aq/resource\*(Aq => sub { ... };
.Ve
.SS "redirect"
.IX Subsection "redirect"
Generates a \s-1HTTP\s0 redirect (302).  You can either redirect to a complete
different site or within the application:
.PP
.Vb 3
\&    get \*(Aq/twitter\*(Aq, sub {
\&        redirect \*(Aqhttp://twitter.com/me\*(Aq;
\&    };
.Ve
.PP
You can also force Dancer to return a specific 300\-ish \s-1HTTP\s0 response code:
.PP
.Vb 3
\&    get \*(Aq/old/:resource\*(Aq, sub {
\&        redirect \*(Aq/new/\*(Aq.params\->{resource}, 301;
\&    };
.Ve
.PP
It is important to note that issuing a redirect by itself does not exit and
redirect immediately, redirection is deferred until after the current route
or filter has been processed. To exit and redirect immediately, use the return
function, e.g.
.PP
.Vb 4
\&    get \*(Aq/restricted\*(Aq, sub {
\&        return redirect \*(Aq/login\*(Aq if accessDenied();
\&        return \*(AqWelcome to the restricted section\*(Aq;
\&    };
.Ve
.SS "render_with_layout"
.IX Subsection "render_with_layout"
Allows a handler to provide plain \s-1HTML\s0 (or other content), but have it rendered
within the layout still.
.PP
This method is \fB\s-1DEPRECATED\s0\fR, and will be removed soon. Instead, you should be
using the \f(CW\*(C`engine\*(C'\fR keyword:
.PP
.Vb 4
\&    get \*(Aq/foo\*(Aq => sub {
\&        # Do something which generates HTML directly (maybe using
\&        # HTML::Table::FromDatabase or something)
\&        my $content = ...;
\&
\&        # get the template engine
\&        my $template_engine = engine \*(Aqtemplate\*(Aq;
\&
\&        # apply the layout (not the renderer), and return the result
\&        $template_engine\->apply_layout($content)
\&    };
.Ve
.PP
It works very similarly to \f(CW\*(C`template\*(C'\fR in that you can pass tokens to be used in
the layout, and/or options to control the way the layout is rendered.  For
instance, to use a custom layout:
.PP
.Vb 1
\&    render_with_layout $content, {}, { layout => \*(Aqlayoutname\*(Aq };
.Ve
.SS "request"
.IX Subsection "request"
Returns a Dancer::Request object representing the current request.
.PP
See the Dancer::Request documention for the methods you can call, for
example:
.PP
.Vb 3
\&    request\->referer;         # value of the HTTP referer header
\&    request\->remote_address;  # user\*(Aqs IP address
\&    request\->user_agent;      # User\-Agent header value
.Ve
.SS "send_error"
.IX Subsection "send_error"
Returns a \s-1HTTP\s0 error.  By default the \s-1HTTP\s0 code returned is 500:
.PP
.Vb 7
\&    get \*(Aq/photo/:id\*(Aq => sub {
\&        if (...) {
\&            send_error("Not allowed", 403);
\&        } else {
\&           # return content
\&        }
\&    }
.Ve
.PP
This will not cause your route handler to return immediately, so be careful that
your route handler doesn't then override the error.  You can avoid that by
saying \f(CW\*(C`return send_error(...)\*(C'\fR instead.
.SS "send_file"
.IX Subsection "send_file"
Lets the current route handler send a file to the client. Note that
the path of the file must be relative to the \fBpublic\fR directory unless you use
the \f(CW\*(C`system_path\*(C'\fR option (see below).
.PP
.Vb 3
\&    get \*(Aq/download/:file\*(Aq => sub {
\&        return send_file(params\->{file});
\&    }
.Ve
.PP
The content-type will be set depending on the current \s-1MIME\s0 types definition
(see \f(CW\*(C`mime\*(C'\fR if you want to define your own).
.PP
If your filename does not have an extension, or you need to force a
specific mime type, you can pass it to \f(CW\*(C`send_file\*(C'\fR as follows:
.PP
.Vb 1
\&    return send_file(params\->{file}, content_type => \*(Aqimage/png\*(Aq);
.Ve
.PP
Also, you can use your aliases or file extension names on
\&\f(CW\*(C`content_type\*(C'\fR, like this:
.PP
.Vb 1
\&    return send_file(params\->{file}, content_type => \*(Aqpng\*(Aq);
.Ve
.PP
For files outside your \fBpublic\fR folder, you can use the \f(CW\*(C`system_path\*(C'\fR
switch. Just bear in mind that its use needs caution as it can be
dangerous.
.PP
.Vb 1
\&   return send_file(\*(Aq/etc/passwd\*(Aq, system_path => 1);
.Ve
.PP
If you have your data in a scalar variable, \f(CW\*(C`send_file\*(C'\fR can be useful
as well. Pass a reference to that scalar, and \f(CW\*(C`send_file\*(C'\fR will behave
as if there was a file with that contents:
.PP
.Vb 1
\&   return send_file( \e$data, content_type => \*(Aqimage/png\*(Aq );
.Ve
.PP
Note that Dancer is unable to guess the content type from the data
contents. Therefore you might need to set the \f(CW\*(C`content_type\*(C'\fR
properly. For this kind of usage an attribute named \f(CW\*(C`filename\*(C'\fR can be
useful.  It is used as the Content-Disposition header, to hint the
brower about the filename it should use.
.PP
.Vb 2
\&   return send_file( \e$data, content_type => \*(Aqimage/png\*(Aq
\&                             filename     => \*(Aqonion.png\*(Aq );
.Ve
.PP
Note that you should always use \f(CW\*(C`return send_file ...\*(C'\fR to stop execution of
your route handler at that point.
.SS "set"
.IX Subsection "set"
Defines a setting:
.PP
.Vb 1
\&    set something => \*(Aqvalue\*(Aq;
.Ve
.PP
You can set more than one value at once:
.PP
.Vb 1
\&    set something => \*(Aqvalue\*(Aq, otherthing => \*(Aqothervalue\*(Aq;
.Ve
.SS "setting"
.IX Subsection "setting"
Returns the value of a given setting:
.PP
.Vb 1
\&    setting(\*(Aqsomething\*(Aq); # \*(Aqvalue\*(Aq
.Ve
.SS "set_cookie"
.IX Subsection "set_cookie"
Creates or updates cookie values:
.PP
.Vb 5
\&    get \*(Aq/some_action\*(Aq => sub {
\&        set_cookie name => \*(Aqvalue\*(Aq,
\&                   expires => (time + 3600),
\&                   domain  => \*(Aq.foo.com\*(Aq;
\&    };
.Ve
.PP
In the example above, only 'name' and 'value' are mandatory.
.PP
You can also store more complex structure in your cookies:
.PP
.Vb 7
\&    get \*(Aq/some_auth\*(Aq => sub {
\&        set_cookie oauth => {
\&            token        => $twitter\->request_token,
\&            token_secret => $twitter\->secret_token,
\&            ...
\&        };
\&    };
.Ve
.PP
You can't store more complex structure than this. All keys in the HashRef
should be Scalars; storing references will not work.
.PP
See Dancer::Cookie for further options when creating your cookie.
.PP
Note that this method will be eventually deprecated in favor of the
new \f(CW\*(C`cookie\*(C'\fR method.
.SS "session"
.IX Subsection "session"
Provides access to all data stored in the user's session (if any).
.PP
It can also be used as a setter to store data in the session:
.PP
.Vb 6
\&    # getter example
\&    get \*(Aq/user\*(Aq => sub {
\&        if (session(\*(Aquser\*(Aq)) {
\&            return "Hello, ".session(\*(Aquser\*(Aq)\->name;
\&        }
\&    };
\&
\&    # setter example
\&    post \*(Aq/user/login\*(Aq => sub {
\&        ...
\&        if ($logged_in) {
\&            session user => $user;
\&        }
\&        ...
\&    };
.Ve
.PP
You may also need to clear a session:
.PP
.Vb 6
\&    # destroy session
\&    get \*(Aq/logout\*(Aq => sub {
\&        ...
\&        session\->destroy;
\&        ...
\&    };
.Ve
.PP
If you need to fetch the session \s-1ID\s0 being used for any reason:
.PP
.Vb 1
\&    my $id = session\->id;
.Ve
.SS "splat"
.IX Subsection "splat"
Returns the list of captures made from a route handler with a route pattern
which includes wildcards:
.PP
.Vb 4
\&    get \*(Aq/file/*.*\*(Aq => sub {
\&        my ($file, $extension) = splat;
\&        ...
\&    };
.Ve
.PP
There is also the extensive splat (A.K.A. \*(L"megasplat\*(R"), which allows extensive
greedier matching, available using two asterisks. The additional path is broken
down and returned as an ArrayRef:
.PP
.Vb 4
\&    get \*(Aq/entry/*/tags/**\*(Aq => sub {
\&        my ( $entry_id, $tags ) = splat;
\&        my @tags = @{$tags};
\&    };
.Ve
.PP
This helps with chained actions:
.PP
.Vb 5
\&    get \*(Aq/team/*/**\*(Aq => sub {
\&        my ($team) = splat;
\&        var team => $team;
\&        pass;
\&    };
\&
\&    prefix \*(Aq/team/*\*(Aq;
\&
\&    get \*(Aq/player/*\*(Aq => sub {
\&        my ($player) = splat;
\&
\&        # etc...
\&    };
\&
\&    get \*(Aq/score\*(Aq => sub {
\&        return score_for( vars\->{\*(Aqteam\*(Aq} );
\&    };
.Ve
.SS "start"
.IX Subsection "start"
Starts the application or the standalone server (depending on the deployment
choices).
.PP
This keyword should be called at the very end of the script, once all routes
are defined.  At this point, Dancer takes over control.
.SS "status"
.IX Subsection "status"
Changes the status code provided by an action.  By default, an action will
produce an \f(CW\*(C`HTTP 200 OK\*(C'\fR status code, meaning everything is \s-1OK:\s0
.PP
.Vb 7
\&    get \*(Aq/download/:file\*(Aq => {
\&        if (! \-f params\->{file}) {
\&            status \*(Aqnot_found\*(Aq;
\&            return "File does not exist, unable to download";
\&        }
\&        # serving the file...
\&    };
.Ve
.PP
In that example, Dancer will notice that the status has changed, and will
render the response accordingly.
.PP
The status keyword receives either a numeric status code or its name in
lower case, with underscores as a separator for blanks \- see the list in
\&\*(L"\s-1HTTP\s0 \s-1CODES\s0\*(R" in Dancer::HTTP.
.SS "template"
.IX Subsection "template"
Tells the route handler to build a response with the current template engine:
.PP
.Vb 4
\&    get \*(Aq/\*(Aq => sub {
\&        ...
\&        template \*(Aqsome_view\*(Aq, { token => \*(Aqvalue\*(Aq};
\&    };
.Ve
.PP
The first parameter should be a template available in the views directory, the
second one (optional) is a HashRef of tokens to interpolate, and the third
(again optional) is a HashRef of options.
.PP
For example, to disable the layout for a specific request:
.PP
.Vb 3
\&    get \*(Aq/\*(Aq => sub {
\&        template \*(Aqindex.tt\*(Aq, {}, { layout => undef };
\&    };
.Ve
.PP
Some tokens are automatically added to your template (\f(CW\*(C`perl_version\*(C'\fR,
\&\f(CW\*(C`dancer_version\*(C'\fR, \f(CW\*(C`settings\*(C'\fR, \f(CW\*(C`request\*(C'\fR, \f(CW\*(C`params\*(C'\fR, \f(CW\*(C`vars\*(C'\fR and, if
you have sessions enabled, \f(CW\*(C`session\*(C'\fR).  Check
Dancer::Template::Abstract for further details.
.SS "to_dumper ($structure)"
.IX Subsection "to_dumper ($structure)"
Serializes a structure with Data::Dumper.
.ie n .SS "to_json ($structure, %options)"
.el .SS "to_json ($structure, \f(CW%options\fP)"
.IX Subsection "to_json ($structure, %options)"
Serializes a structure to \s-1JSON\s0. Can receive optional arguments. Thoses arguments
are valid \s-1JSON\s0 arguments to change the behaviour of the default
\&\f(CW\*(C`JSON::to_json\*(C'\fR function.
.SS "to_yaml ($structure)"
.IX Subsection "to_yaml ($structure)"
Serializes a structure to \s-1YAML\s0.
.ie n .SS "to_xml ($structure, %options)"
.el .SS "to_xml ($structure, \f(CW%options\fP)"
.IX Subsection "to_xml ($structure, %options)"
Serializes a structure to \s-1XML\s0. Can receive optional arguments. Thoses arguments
are valid XML::Simple arguments to change the behaviour of the default
\&\f(CW\*(C`XML::Simple::XMLout\*(C'\fR function.
.SS "true"
.IX Subsection "true"
Constant that returns a true value (1).
.SS "upload"
.IX Subsection "upload"
Provides access to file uploads.  Any uploaded file is accessible as a
Dancer::Request::Upload object. You can access all parsed uploads via:
.PP
.Vb 4
\&    post \*(Aq/some/route\*(Aq => sub {
\&        my $file = upload(\*(Aqfile_input_foo\*(Aq);
\&        # file is a Dancer::Request::Upload object
\&    };
.Ve
.PP
If you named multiple input of type \*(L"file\*(R" with the same name, the upload
keyword will return an Array of Dancer::Request::Upload objects:
.PP
.Vb 4
\&    post \*(Aq/some/route\*(Aq => sub {
\&        my ($file1, $file2) = upload(\*(Aqfiles_input\*(Aq);
\&        # $file1 and $file2 are Dancer::Request::Upload objects
\&    };
.Ve
.PP
You can also access the raw HashRef of parsed uploads via the current request
object:
.PP
.Vb 5
\&    post \*(Aq/some/route\*(Aq => sub {
\&        my $all_uploads = request\->uploads;
\&        # $all_uploads\->{\*(Aqfile_input_foo\*(Aq} is a Dancer::Request::Upload object
\&        # $all_uploads\->{\*(Aqfiles_input\*(Aq} is an ArrayRef of Dancer::Request::Upload objects
\&    };
.Ve
.PP
Note that you can also access the filename of the upload received via the params
keyword:
.PP
.Vb 3
\&    post \*(Aq/some/route\*(Aq => sub {
\&        # params\->{\*(Aqfiles_input\*(Aq} is the filename of the file uploaded
\&    };
.Ve
.PP
See Dancer::Request::Upload for details about the interface provided.
.SS "uri_for"
.IX Subsection "uri_for"
Returns a fully-qualified \s-1URI\s0 for the given path:
.PP
.Vb 4
\&    get \*(Aq/\*(Aq => sub {
\&        redirect uri_for(\*(Aq/path\*(Aq);
\&        # can be something like: http://localhost:3000/path
\&    };
.Ve
.SS "captures"
.IX Subsection "captures"
Returns a reference to a copy of \f(CW\*(C`%+\*(C'\fR, if there are named captures in the route
Regexp.
.PP
Named captures are a feature of Perl 5.10, and are not supported in earlier
versions:
.PP
.Vb 10
\&    get qr{
\&        / (?<object> user   | ticket | comment )
\&        / (?<action> delete | find )
\&        / (?<id> \ed+ )
\&        /?$
\&    }x
\&    , sub {
\&        my $value_for = captures;
\&        "i don\*(Aqt want to $$value_for{action} the $$value_for{object} $$value_for{id} !"
\&    };
.Ve
.SS "var"
.IX Subsection "var"
Defines a variable shared between filters and route handlers.
.PP
.Vb 3
\&    before sub {
\&        var foo => 42;
\&    };
.Ve
.PP
Route handlers and other filters will be able to read that variable with the
\&\f(CW\*(C`vars\*(C'\fR keyword.
.SS "vars"
.IX Subsection "vars"
Returns the HashRef of all shared variables set during the filter/route
chain:
.PP
.Vb 5
\&    get \*(Aq/path\*(Aq => sub {
\&        if (vars\->{foo} eq 42) {
\&            ...
\&        }
\&    };
.Ve
.SS "warning"
.IX Subsection "warning"
Logs a warning message through the current logger engine:
.PP
.Vb 1
\&    warning "This is a warning";
.Ve
.PP
See Dancer::Logger for details on how to configure where log messages go.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module has been written by Alexis Sukrieh <sukria@cpan.org> and others,
see the \s-1AUTHORS\s0 file that comes with this distribution for details.
.SH "SOURCE CODE"
.IX Header "SOURCE CODE"
The source code for this module is hosted on GitHub
<http://github.com/sukria/Dancer>.  Feel free to fork the repository and submit
pull requests!  (See Dancer::Development for details on how to contribute).
.PP
Also, why not watch the repo <https://github.com/sukria/Dancer/toggle_watch> to
keep up to date with the latest upcoming changes?
.SH "GETTING HELP / CONTRIBUTING"
.IX Header "GETTING HELP / CONTRIBUTING"
The Dancer development team can be found on #dancer on irc.perl.org:
<irc://irc.perl.org/dancer>
.PP
If you don't have an \s-1IRC\s0 client installed/configured, there is a simple web chat
client at <http://www.perldancer.org/irc> for you.
.PP
There is also a Dancer users mailing list available \- subscribe at:
.PP
http://lists.perldancer.org/cgi\-bin/listinfo/dancer\-users <http://lists.perldancer.org/cgi-bin/listinfo/dancer-users>
.PP
If you'd like to contribute to the Dancer project, please see
<http://www.perldancer.org/contribute> for all the ways you can help!
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
The following modules are mandatory (Dancer cannot run without them):
.IP "HTTP::Server::Simple::PSGI" 8
.IX Item "HTTP::Server::Simple::PSGI"
.PD 0
.IP "HTTP::Body" 8
.IX Item "HTTP::Body"
.IP "\s-1LWP\s0" 8
.IX Item "LWP"
.IP "MIME::Types" 8
.IX Item "MIME::Types"
.IP "\s-1URI\s0" 8
.IX Item "URI"
.PD
.PP
The following modules are optional:
.IP "\s-1JSON\s0 : needed to use \s-1JSON\s0 serializer" 8
.IX Item "JSON : needed to use JSON serializer"
.PD 0
.IP "Plack : in order to use \s-1PSGI\s0" 8
.IX Item "Plack : in order to use PSGI"
.IP "Template : in order to use \s-1TT\s0 for rendering views" 8
.IX Item "Template : in order to use TT for rendering views"
.IP "XML::Simple and \s-1XML:SAX\s0 <XML:SAX> or <XML:Parser> for \s-1XML\s0 serialization" 8
.IX Item "XML::Simple and XML:SAX <XML:SAX> or <XML:Parser> for XML serialization"
.IP "\s-1YAML\s0 : needed for configuration file support" 8
.IX Item "YAML : needed for configuration file support"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software and is published under the same
terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Main Dancer web site: <http://perldancer.org/>.
.PP
The concept behind this module comes from the Sinatra ruby project,
see <http://www.sinatrarb.com/> for details.
